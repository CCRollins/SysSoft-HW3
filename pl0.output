Nonterminals useless in grammar

    constDef
    constDefs
    posSign


Terminals unused in grammar

    "+"
    "-"
    "."
    ":="
    "end"


Rules useless in grammar

   52 constDef: "const" identsym ":=" numbersym

   53 constDefs: constDef
   54          | constDefs "," constDef

   55 posSign: "+"
   56        | ε


Rules useless in parser due to conflicts

   30 writeStmt: "write" expr ";"


State 40 conflicts: 8 shift/reduce
State 49 conflicts: 6 shift/reduce
State 73 conflicts: 10 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: block

    2 block: constDecls varDecls procDecls stmt

    3 constDecls: empty
    4           | constDecls constDecl

    5 constDecl: "const"

    6 varDecls: empty
    7         | varDecls varDecl

    8 varDecl: "var" idents

    9 idents: identsym
   10       | idents "," identsym

   11 procDecls: empty
   12          | procDecls procDecl

   13 procDecl: "procedure" identsym ";" block

   14 stmt: assignStmt
   15     | callStmt
   16     | beginStmt
   17     | ifStmt
   18     | whileStmt
   19     | readStmt
   20     | writeStmt
   21     | skipStmt

   22 assignStmt: identsym "=" expr ";"

   23 callStmt: "call" identsym

   24 beginStmt: "begin" stmts

   25 ifStmt: "if" condition "then" "else"

   26 whileStmt: "while" condition "do" stmt

   27 readStmt: "read" identsym ";"

   28 writeStmt: "write" expr ";"

   29 skipStmt: "skip"

   30 writeStmt: "write" expr ";"

   31 stmts: stmt
   32      | stmts stmt

   33 condition: oddCondition
   34          | relOpCondition

   35 oddCondition: "odd" expr

   36 relOpCondition: expr relOp expr

   37 relOp: "="
   38      | "<>"
   39      | "<"
   40      | "<="
   41      | ">"
   42      | ">="

   43 expr: term
   44     | term relOp term

   45 term: factor
   46     | term "*" factor
   47     | term "/" factor

   48 factor: identsym
   49       | numbersym
   50       | "(" expr ")"

   51 empty: ε


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    identsym <ident> (258) 9 10 13 22 23 27 48
    numbersym <number> (259) 49
    "+" <token> (260)
    "-" <token> (261)
    "*" <token> (262) 46
    "/" <token> (263) 47
    "." <token> (264)
    ";" <token> (265) 13 22 27 28 30
    "=" <token> (266) 22 37
    "," <token> (267) 10
    ":=" <token> (268)
    "const" <token> (269) 5
    "var" <token> (270) 8
    "procedure" <token> (271) 13
    "call" <token> (272) 23
    "begin" <token> (273) 24
    "end" <token> (274)
    "if" <token> (275) 25
    "then" <token> (276) 25
    "else" <token> (277) 25
    "while" <token> (278) 26
    "do" <token> (279) 26
    "read" <token> (280) 27
    "write" <token> (281) 28 30
    "skip" <token> (282) 29
    "odd" <token> (283) 35
    "<>" <token> (284) 38
    "<" <token> (285) 39
    "<=" <token> (286) 40
    ">" <token> (287) 41
    ">=" <token> (288) 42
    "(" <token> (289) 50
    ")" <token> (290) 50


Nonterminals, with rules where they appear

    $accept (36)
        on left: 0
    program <block> (37)
        on left: 1
        on right: 0
    block <block> (38)
        on left: 2
        on right: 1 13
    constDecls <const_decls> (39)
        on left: 3 4
        on right: 2 4
    constDecl <const_decl> (40)
        on left: 5
        on right: 4
    varDecls <var_decls> (41)
        on left: 6 7
        on right: 2 7
    varDecl <var_decl> (42)
        on left: 8
        on right: 7
    idents <idents> (43)
        on left: 9 10
        on right: 8 10
    procDecls <proc_decls> (44)
        on left: 11 12
        on right: 2 12
    procDecl <proc_decl> (45)
        on left: 13
        on right: 12
    stmt <stmt> (46)
        on left: 14 15 16 17 18 19 20 21
        on right: 2 26 31 32
    assignStmt <assign_stmt> (47)
        on left: 22
        on right: 14
    callStmt <call_stmt> (48)
        on left: 23
        on right: 15
    beginStmt <begin_stmt> (49)
        on left: 24
        on right: 16
    ifStmt <if_stmt> (50)
        on left: 25
        on right: 17
    whileStmt <while_stmt> (51)
        on left: 26
        on right: 18
    readStmt <read_stmt> (52)
        on left: 27
        on right: 19
    writeStmt <write_stmt> (53)
        on left: 28 30
        on right: 20
    skipStmt <skip_stmt> (54)
        on left: 29
        on right: 21
    stmts <stmts> (55)
        on left: 31 32
        on right: 24 32
    condition <condition> (56)
        on left: 33 34
        on right: 25 26
    oddCondition <odd_condition> (57)
        on left: 35
        on right: 33
    relOpCondition <rel_op_condition> (58)
        on left: 36
        on right: 34
    relOp <token> (59)
        on left: 37 38 39 40 41 42
        on right: 36 44
    expr <expr> (60)
        on left: 43 44
        on right: 22 28 30 35 36 50
    term <expr> (61)
        on left: 45 46 47
        on right: 43 44 46 47
    factor <expr> (62)
        on left: 48 49 50
        on right: 45 46 47
    empty <empty> (63)
        on left: 51
        on right: 3 6 11


State 0

    0 $accept: • program $end

    $default  reduce using rule 51 (empty)

    program     go to state 1
    block       go to state 2
    constDecls  go to state 3
    empty       go to state 4


State 1

    0 $accept: program • $end

    $end  shift, and go to state 5


State 2

    1 program: block •

    $default  reduce using rule 1 (program)


State 3

    2 block: constDecls • varDecls procDecls stmt
    4 constDecls: constDecls • constDecl

    "const"  shift, and go to state 6

    $default  reduce using rule 51 (empty)

    constDecl  go to state 7
    varDecls   go to state 8
    empty      go to state 9


State 4

    3 constDecls: empty •

    $default  reduce using rule 3 (constDecls)


State 5

    0 $accept: program $end •

    $default  accept


State 6

    5 constDecl: "const" •

    $default  reduce using rule 5 (constDecl)


State 7

    4 constDecls: constDecls constDecl •

    $default  reduce using rule 4 (constDecls)


State 8

    2 block: constDecls varDecls • procDecls stmt
    7 varDecls: varDecls • varDecl

    "var"  shift, and go to state 10

    $default  reduce using rule 51 (empty)

    varDecl    go to state 11
    procDecls  go to state 12
    empty      go to state 13


State 9

    6 varDecls: empty •

    $default  reduce using rule 6 (varDecls)


State 10

    8 varDecl: "var" • idents

    identsym  shift, and go to state 14

    idents  go to state 15


State 11

    7 varDecls: varDecls varDecl •

    $default  reduce using rule 7 (varDecls)


State 12

    2 block: constDecls varDecls procDecls • stmt
   12 procDecls: procDecls • procDecl

    identsym     shift, and go to state 16
    "procedure"  shift, and go to state 17
    "call"       shift, and go to state 18
    "begin"      shift, and go to state 19
    "if"         shift, and go to state 20
    "while"      shift, and go to state 21
    "read"       shift, and go to state 22
    "write"      shift, and go to state 23
    "skip"       shift, and go to state 24

    procDecl    go to state 25
    stmt        go to state 26
    assignStmt  go to state 27
    callStmt    go to state 28
    beginStmt   go to state 29
    ifStmt      go to state 30
    whileStmt   go to state 31
    readStmt    go to state 32
    writeStmt   go to state 33
    skipStmt    go to state 34


State 13

   11 procDecls: empty •

    $default  reduce using rule 11 (procDecls)


State 14

    9 idents: identsym •

    $default  reduce using rule 9 (idents)


State 15

    8 varDecl: "var" idents •
   10 idents: idents • "," identsym

    ","  shift, and go to state 35

    $default  reduce using rule 8 (varDecl)


State 16

   22 assignStmt: identsym • "=" expr ";"

    "="  shift, and go to state 36


State 17

   13 procDecl: "procedure" • identsym ";" block

    identsym  shift, and go to state 37


State 18

   23 callStmt: "call" • identsym

    identsym  shift, and go to state 38


State 19

   24 beginStmt: "begin" • stmts

    identsym  shift, and go to state 16
    "call"    shift, and go to state 18
    "begin"   shift, and go to state 19
    "if"      shift, and go to state 20
    "while"   shift, and go to state 21
    "read"    shift, and go to state 22
    "write"   shift, and go to state 23
    "skip"    shift, and go to state 24

    stmt        go to state 39
    assignStmt  go to state 27
    callStmt    go to state 28
    beginStmt   go to state 29
    ifStmt      go to state 30
    whileStmt   go to state 31
    readStmt    go to state 32
    writeStmt   go to state 33
    skipStmt    go to state 34
    stmts       go to state 40


State 20

   25 ifStmt: "if" • condition "then" "else"

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "odd"      shift, and go to state 43
    "("        shift, and go to state 44

    condition       go to state 45
    oddCondition    go to state 46
    relOpCondition  go to state 47
    expr            go to state 48
    term            go to state 49
    factor          go to state 50


State 21

   26 whileStmt: "while" • condition "do" stmt

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "odd"      shift, and go to state 43
    "("        shift, and go to state 44

    condition       go to state 51
    oddCondition    go to state 46
    relOpCondition  go to state 47
    expr            go to state 48
    term            go to state 49
    factor          go to state 50


State 22

   27 readStmt: "read" • identsym ";"

    identsym  shift, and go to state 52


State 23

   28 writeStmt: "write" • expr ";"
   30          | "write" • expr ";"

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "("        shift, and go to state 44

    expr    go to state 53
    term    go to state 49
    factor  go to state 50


State 24

   29 skipStmt: "skip" •

    $default  reduce using rule 29 (skipStmt)


State 25

   12 procDecls: procDecls procDecl •

    $default  reduce using rule 12 (procDecls)


State 26

    2 block: constDecls varDecls procDecls stmt •

    $default  reduce using rule 2 (block)


State 27

   14 stmt: assignStmt •

    $default  reduce using rule 14 (stmt)


State 28

   15 stmt: callStmt •

    $default  reduce using rule 15 (stmt)


State 29

   16 stmt: beginStmt •

    $default  reduce using rule 16 (stmt)


State 30

   17 stmt: ifStmt •

    $default  reduce using rule 17 (stmt)


State 31

   18 stmt: whileStmt •

    $default  reduce using rule 18 (stmt)


State 32

   19 stmt: readStmt •

    $default  reduce using rule 19 (stmt)


State 33

   20 stmt: writeStmt •

    $default  reduce using rule 20 (stmt)


State 34

   21 stmt: skipStmt •

    $default  reduce using rule 21 (stmt)


State 35

   10 idents: idents "," • identsym

    identsym  shift, and go to state 54


State 36

   22 assignStmt: identsym "=" • expr ";"

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "("        shift, and go to state 44

    expr    go to state 55
    term    go to state 49
    factor  go to state 50


State 37

   13 procDecl: "procedure" identsym • ";" block

    ";"  shift, and go to state 56


State 38

   23 callStmt: "call" identsym •

    $default  reduce using rule 23 (callStmt)


State 39

   31 stmts: stmt •

    $default  reduce using rule 31 (stmts)


State 40

   24 beginStmt: "begin" stmts •
   32 stmts: stmts • stmt

    identsym  shift, and go to state 16
    "call"    shift, and go to state 18
    "begin"   shift, and go to state 19
    "if"      shift, and go to state 20
    "while"   shift, and go to state 21
    "read"    shift, and go to state 22
    "write"   shift, and go to state 23
    "skip"    shift, and go to state 24

    identsym  [reduce using rule 24 (beginStmt)]
    "call"    [reduce using rule 24 (beginStmt)]
    "begin"   [reduce using rule 24 (beginStmt)]
    "if"      [reduce using rule 24 (beginStmt)]
    "while"   [reduce using rule 24 (beginStmt)]
    "read"    [reduce using rule 24 (beginStmt)]
    "write"   [reduce using rule 24 (beginStmt)]
    "skip"    [reduce using rule 24 (beginStmt)]
    $default  reduce using rule 24 (beginStmt)

    stmt        go to state 57
    assignStmt  go to state 27
    callStmt    go to state 28
    beginStmt   go to state 29
    ifStmt      go to state 30
    whileStmt   go to state 31
    readStmt    go to state 32
    writeStmt   go to state 33
    skipStmt    go to state 34


State 41

   48 factor: identsym •

    $default  reduce using rule 48 (factor)


State 42

   49 factor: numbersym •

    $default  reduce using rule 49 (factor)


State 43

   35 oddCondition: "odd" • expr

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "("        shift, and go to state 44

    expr    go to state 58
    term    go to state 49
    factor  go to state 50


State 44

   50 factor: "(" • expr ")"

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "("        shift, and go to state 44

    expr    go to state 59
    term    go to state 49
    factor  go to state 50


State 45

   25 ifStmt: "if" condition • "then" "else"

    "then"  shift, and go to state 60


State 46

   33 condition: oddCondition •

    $default  reduce using rule 33 (condition)


State 47

   34 condition: relOpCondition •

    $default  reduce using rule 34 (condition)


State 48

   36 relOpCondition: expr • relOp expr

    "="   shift, and go to state 61
    "<>"  shift, and go to state 62
    "<"   shift, and go to state 63
    "<="  shift, and go to state 64
    ">"   shift, and go to state 65
    ">="  shift, and go to state 66

    relOp  go to state 67


State 49

   43 expr: term •
   44     | term • relOp term
   46 term: term • "*" factor
   47     | term • "/" factor

    "*"   shift, and go to state 68
    "/"   shift, and go to state 69
    "="   shift, and go to state 61
    "<>"  shift, and go to state 62
    "<"   shift, and go to state 63
    "<="  shift, and go to state 64
    ">"   shift, and go to state 65
    ">="  shift, and go to state 66

    "="       [reduce using rule 43 (expr)]
    "<>"      [reduce using rule 43 (expr)]
    "<"       [reduce using rule 43 (expr)]
    "<="      [reduce using rule 43 (expr)]
    ">"       [reduce using rule 43 (expr)]
    ">="      [reduce using rule 43 (expr)]
    $default  reduce using rule 43 (expr)

    relOp  go to state 70


State 50

   45 term: factor •

    $default  reduce using rule 45 (term)


State 51

   26 whileStmt: "while" condition • "do" stmt

    "do"  shift, and go to state 71


State 52

   27 readStmt: "read" identsym • ";"

    ";"  shift, and go to state 72


State 53

   28 writeStmt: "write" expr • ";"
   30          | "write" expr • ";"

    ";"  shift, and go to state 73


State 54

   10 idents: idents "," identsym •

    $default  reduce using rule 10 (idents)


State 55

   22 assignStmt: identsym "=" expr • ";"

    ";"  shift, and go to state 74


State 56

   13 procDecl: "procedure" identsym ";" • block

    $default  reduce using rule 51 (empty)

    block       go to state 75
    constDecls  go to state 3
    empty       go to state 4


State 57

   32 stmts: stmts stmt •

    $default  reduce using rule 32 (stmts)


State 58

   35 oddCondition: "odd" expr •

    $default  reduce using rule 35 (oddCondition)


State 59

   50 factor: "(" expr • ")"

    ")"  shift, and go to state 76


State 60

   25 ifStmt: "if" condition "then" • "else"

    "else"  shift, and go to state 77


State 61

   37 relOp: "=" •

    $default  reduce using rule 37 (relOp)


State 62

   38 relOp: "<>" •

    $default  reduce using rule 38 (relOp)


State 63

   39 relOp: "<" •

    $default  reduce using rule 39 (relOp)


State 64

   40 relOp: "<=" •

    $default  reduce using rule 40 (relOp)


State 65

   41 relOp: ">" •

    $default  reduce using rule 41 (relOp)


State 66

   42 relOp: ">=" •

    $default  reduce using rule 42 (relOp)


State 67

   36 relOpCondition: expr relOp • expr

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "("        shift, and go to state 44

    expr    go to state 78
    term    go to state 49
    factor  go to state 50


State 68

   46 term: term "*" • factor

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "("        shift, and go to state 44

    factor  go to state 79


State 69

   47 term: term "/" • factor

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "("        shift, and go to state 44

    factor  go to state 80


State 70

   44 expr: term relOp • term

    identsym   shift, and go to state 41
    numbersym  shift, and go to state 42
    "("        shift, and go to state 44

    term    go to state 81
    factor  go to state 50


State 71

   26 whileStmt: "while" condition "do" • stmt

    identsym  shift, and go to state 16
    "call"    shift, and go to state 18
    "begin"   shift, and go to state 19
    "if"      shift, and go to state 20
    "while"   shift, and go to state 21
    "read"    shift, and go to state 22
    "write"   shift, and go to state 23
    "skip"    shift, and go to state 24

    stmt        go to state 82
    assignStmt  go to state 27
    callStmt    go to state 28
    beginStmt   go to state 29
    ifStmt      go to state 30
    whileStmt   go to state 31
    readStmt    go to state 32
    writeStmt   go to state 33
    skipStmt    go to state 34


State 72

   27 readStmt: "read" identsym ";" •

    $default  reduce using rule 27 (readStmt)


State 73

   28 writeStmt: "write" expr ";" •
   30          | "write" expr ";" •

    $end         reduce using rule 28 (writeStmt)
    $end         [reduce using rule 30 (writeStmt)]
    identsym     reduce using rule 28 (writeStmt)
    identsym     [reduce using rule 30 (writeStmt)]
    "procedure"  reduce using rule 28 (writeStmt)
    "procedure"  [reduce using rule 30 (writeStmt)]
    "call"       reduce using rule 28 (writeStmt)
    "call"       [reduce using rule 30 (writeStmt)]
    "begin"      reduce using rule 28 (writeStmt)
    "begin"      [reduce using rule 30 (writeStmt)]
    "if"         reduce using rule 28 (writeStmt)
    "if"         [reduce using rule 30 (writeStmt)]
    "while"      reduce using rule 28 (writeStmt)
    "while"      [reduce using rule 30 (writeStmt)]
    "read"       reduce using rule 28 (writeStmt)
    "read"       [reduce using rule 30 (writeStmt)]
    "write"      reduce using rule 28 (writeStmt)
    "write"      [reduce using rule 30 (writeStmt)]
    "skip"       reduce using rule 28 (writeStmt)
    "skip"       [reduce using rule 30 (writeStmt)]
    $default     reduce using rule 28 (writeStmt)


State 74

   22 assignStmt: identsym "=" expr ";" •

    $default  reduce using rule 22 (assignStmt)


State 75

   13 procDecl: "procedure" identsym ";" block •

    $default  reduce using rule 13 (procDecl)


State 76

   50 factor: "(" expr ")" •

    $default  reduce using rule 50 (factor)


State 77

   25 ifStmt: "if" condition "then" "else" •

    $default  reduce using rule 25 (ifStmt)


State 78

   36 relOpCondition: expr relOp expr •

    $default  reduce using rule 36 (relOpCondition)


State 79

   46 term: term "*" factor •

    $default  reduce using rule 46 (term)


State 80

   47 term: term "/" factor •

    $default  reduce using rule 47 (term)


State 81

   44 expr: term relOp term •
   46 term: term • "*" factor
   47     | term • "/" factor

    "*"  shift, and go to state 68
    "/"  shift, and go to state 69

    $default  reduce using rule 44 (expr)


State 82

   26 whileStmt: "while" condition "do" stmt •

    $default  reduce using rule 26 (whileStmt)
